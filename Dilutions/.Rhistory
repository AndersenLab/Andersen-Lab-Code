} else {
pval = 1 - pnorm(zstat)
}
append(y, pval)
}
zstat = propTest(i)
if(zstat < 0){
pval = pnorm(zstat)
} else {
pval = 1 - pnorm(zstat)
}
zstat = propTest(.24)
if(zstat < 0){
pval = pnorm(zstat)
} else {
pval = 1 - pnorm(zstat)
}
append(y,pval)
y = c()
for(i in x){
zstat = propTest(.24)
if(zstat < 0){
pval = pnorm(zstat)
} else {
pval = 1 - pnorm(zstat)
}
propTest = function(x){
(.04 - x)/((x*(1-x))/25)
}
x = seq(0,1,.01)
y = c()
for(i in x){
zstat = propTest(i)
if(zstat < 0){
pval = pnorm(zstat)
} else {
pval = 1 - pnorm(zstat)
}
y = append(y,pval)
}
}
propTest = function(x){
(.04 - x)/((x*(1-x))/25)
}
x = seq(0,1,.01)
y = c()
for(i in x){
zstat = propTest(i)
if(zstat < 0){
pval = pnorm(zstat)
} else {
pval = 1 - pnorm(zstat)
}
y = append(y,pval)
}
plot(x,y)
y
cbind(x,y)
data = read.csv("jn6CompleteScoring.csv")
View(data)
anova = aov(data$Non~data$F1.Plate)
summary(anova)
anova = aov(data$Act~data$F1.Plate)
summary(anova)
length(data)
nrow(data)
View(data)
View(data)
data = read.csv("jn6CompleteScoring.csv")
View(data)
data = read.csv("jn6CompleteScoring.csv")
genotype = c()
for(i in seq(nrowdata)){
if(data[i,2] != 0 & data[i,3] != 0){
n = data[i,2] + data[i,3]
pHat = data[i,3]/n
pHet = .47
pHomo = .91
pWT = .00
zHet = abs((pHat-pHet)/sqrt((pHet*(1-pHet))/n))
zHomo = abs((pHat-pHomo)/sqrt((pHomo*(1-pHomo))/n))
zWT = abs((pHat-pWT)/sqrt((pWT*(1-pWT))/n))
if(zHet < zHomo & zHet < zWT){
gene = "Heterzygous"
} else if(zHomo < zHet & zHomo < zWT) {
gene = "Suppressed"
} else if(zWT < zHet & zWT < zHomo) {
gene = "Wild-type"
}
genotype[i] = gene
}
}
for(i in seq(nrow(data))){
if(data[i,2] != 0 & data[i,3] != 0){
n = data[i,2] + data[i,3]
pHat = data[i,3]/n
pHet = .47
pHomo = .91
pWT = .00
zHet = abs((pHat-pHet)/sqrt((pHet*(1-pHet))/n))
zHomo = abs((pHat-pHomo)/sqrt((pHomo*(1-pHomo))/n))
zWT = abs((pHat-pWT)/sqrt((pWT*(1-pWT))/n))
if(zHet < zHomo & zHet < zWT){
gene = "Heterzygous"
} else if(zHomo < zHet & zHomo < zWT) {
gene = "Suppressed"
} else if(zWT < zHet & zWT < zHomo) {
gene = "Wild-type"
}
genotype[i] = gene
}
}
data = read.csv("jn6CompleteScoring.csv")
# het (53,47)
# homo (9,91)
genotype = c()
for(i in seq(nrow(data))){
if(data[i,2] != NA & data[i,3] != NA){
n = data[i,2] + data[i,3]
pHat = data[i,3]/n
pHet = .47
pHomo = .91
pWT = .00
zHet = abs((pHat-pHet)/sqrt((pHet*(1-pHet))/n))
zHomo = abs((pHat-pHomo)/sqrt((pHomo*(1-pHomo))/n))
zWT = abs((pHat-pWT)/sqrt((pWT*(1-pWT))/n))
if(zHet < zHomo & zHet < zWT){
gene = "Heterzygous"
} else if(zHomo < zHet & zHomo < zWT) {
gene = "Suppressed"
} else if(zWT < zHet & zWT < zHomo) {
gene = "Wild-type"
}
genotype[i] = gene
}
}
for(i in seq(nrow(data))){
if(!is.na(data[i,2]) & !is.na(data[i,3])){
n = data[i,2] + data[i,3]
pHat = data[i,3]/n
pHet = .47
pHomo = .91
pWT = .00
zHet = abs((pHat-pHet)/sqrt((pHet*(1-pHet))/n))
zHomo = abs((pHat-pHomo)/sqrt((pHomo*(1-pHomo))/n))
zWT = abs((pHat-pWT)/sqrt((pWT*(1-pWT))/n))
if(zHet < zHomo & zHet < zWT){
gene = "Heterzygous"
} else if(zHomo < zHet & zHomo < zWT) {
gene = "Suppressed"
} else if(zWT < zHet & zWT < zHomo) {
gene = "Wild-type"
}
genotype[i] = gene
}
}
zHet < zHomo & zHet < zWT
for(i in seq(nrow(data))){
if(!is.na(data[i,2]) & !is.na(data[i,3])){
n = data[i,2] + data[i,3]
pHat = data[i,3]/n
pHet = .47
pHomo = .91
pWT = .00
zHet = as.numeric(abs((pHat-pHet)/sqrt((pHet*(1-pHet))/n)))
zHomo = as.numeric(abs((pHat-pHomo)/sqrt((pHomo*(1-pHomo))/n)))
zWT = as.numeric(abs((pHat-pWT)/sqrt((pWT*(1-pWT))/n)))
if(zHet < zHomo & zHet < zWT){
gene = "Heterzygous"
} else if(zHomo < zHet & zHomo < zWT) {
gene = "Suppressed"
} else if(zWT < zHet & zWT < zHomo) {
gene = "Wild-type"
}
genotype[i] = gene
}
}
(0-0)/sqrt((0*(1-0))/12))
(0-0)/sqrt((0*(1-0))/12)
for(i in seq(nrow(data))){
if(!is.na(data[i,2]) & !is.na(data[i,3])){
n = data[i,2] + data[i,3]
pHat = data[i,3]/n
pHet = .47
pHomo = .91
pWT = .01
zHet = as.numeric(abs((pHat-pHet)/sqrt((pHet*(1-pHet))/n)))
zHomo = as.numeric(abs((pHat-pHomo)/sqrt((pHomo*(1-pHomo))/n)))
zWT = as.numeric(abs((pHat-pWT)/sqrt((pWT*(1-pWT))/n)))
if(zHet < zHomo & zHet < zWT){
gene = "Heterzygous"
} else if(zHomo < zHet & zHomo < zWT) {
gene = "Suppressed"
} else if(zWT < zHet & zWT < zHomo) {
gene = "Wild-type"
}
genotype[i] = gene
}
}
n = data[i,2] + data[i,3]
data = read.csv("jn6CompleteScoring.csv")
genotype = c()
for(i in seq(nrow(data))){
if(!is.na(data[i,2]) & !is.na(data[i,3])){
n = data[i,2] + data[i,3]
pHat = data[i,3]/n
pHet = .47
pHomo = .91
pWT = .01
zHet = as.numeric(abs((pHat-pHet)/sqrt((pHet*(1-pHet))/n)))
zHomo = as.numeric(abs((pHat-pHomo)/sqrt((pHomo*(1-pHomo))/n)))
zWT = as.numeric(abs((pHat-pWT)/sqrt((pWT*(1-pWT))/n)))
if(zHet < zHomo & zHet < zWT){
gene = "Heterzygous"
} else if(zHomo < zHet & zHomo < zWT) {
gene = "Suppressed"
} else if(zWT < zHet & zWT < zHomo) {
gene = "Wild-type"
}
genotype[i] = gene
}
}
View(data)
data = read.csv("jn6CompleteScoring.csv")
View(data)
data = read.csv("jn6CompleteScoring.csv")
data = read.csv("jn6CompleteScoring.csv")
View(data)
data = read.csv("jn6CompleteScoring.csv")
# het (53,47)
# homo (9,91)
genotype = c()
for(i in seq(nrow(data))){
if(!is.na(data[i,2]) & !is.na(data[i,3])){
n = data[i,2] + data[i,3]
pHat = data[i,3]/n
pHet = .47
pHomo = .91
pWT = .01
zHet = as.numeric(abs((pHat-pHet)/sqrt((pHet*(1-pHet))/n)))
zHomo = as.numeric(abs((pHat-pHomo)/sqrt((pHomo*(1-pHomo))/n)))
zWT = as.numeric(abs((pHat-pWT)/sqrt((pWT*(1-pWT))/n)))
if(zHet < zHomo & zHet < zWT){
gene = "Heterzygous"
} else if(zHomo < zHet & zHomo < zWT) {
gene = "Suppressed"
} else if(zWT < zHet & zWT < zHomo) {
gene = "Wild-type"
}
genotype[i] = gene
}
}
cbind(data, genotype)
data = cbind(data, genotype)
View(data)
write.table(data, file = "jn6.csv")
write.table(data, file = "jn6.csv", sep = ",")
data = read.csv("jn6CompleteScoring.csv")
# het (53,47)
# homo (9,91)
genotype = c()
for(i in seq(nrow(data))){
if(!is.na(data[i,2]) & !is.na(data[i,3])){
n = data[i,2] + data[i,3]
pHat = data[i,3]/n
pHet = .47
pHomo = .91
pWT = .01
zHet = as.numeric(abs((pHat-pHet)/sqrt((pHet*(1-pHet))/n)))
zHomo = as.numeric(abs((pHat-pHomo)/sqrt((pHomo*(1-pHomo))/n)))
zWT = as.numeric(abs((pHat-pWT)/sqrt((pWT*(1-pWT))/n)))
if(zHet < zHomo & zHet < zWT){
gene = "Heterozygous"
} else if(zHomo < zHet & zHomo < zWT) {
gene = "Suppressed"
} else if(zWT < zHet & zWT < zHomo) {
gene = "Wild-type"
}
genotype[i] = gene
}
}
write.table(data, file = "jn6.csv", sep = ",")
data = cbind(data, genotype)
write.table(data, file = "jn6.csv", sep = ",")
table(data$genotype)
prop.table(data$genotype)
64+8+51
64/123
51/123
51/1238/123
8/123
anova = aov(data$genotype~data$F1.Plate)
data$F1.Plate = as.factor(data$F1.Plate)
anova = aov(data$genotype~data$F1.Plate)
library(MASS)
data(Cars93)
Cars93
fit = lm(MPG.city ~ EngineSize + Weight + Passengers + Price)
fit = lm(MPG.city ~ EngineSize + Weight + Passengers + Price, data = Cars93)
summary(fit)
plot(MPG.city ~ EngineSize + Weight + Passengers + Price, data = Cars93)
plot(Cars93)
colnames(Cars93)
pairs(Cars93[,c(5,7,12,18,25)])
b0 + b1*10 + b2*.5 + b3*50 + b4*100
b0 = 1.52
b1 = .02
b2 = -1.40
b3 = .02
b4 = -.0006
b0 + b1*10 + b2*.5 + b3*50 + b4*100
b0 + b1*20 + b2*.5 + b3*10 + b4*30
.0006*100
r2 = 1 - 20/39.2
f = (r2/4)/((1-r2)/(30-(4+1)))
f >= qf(.95,4,25)
attach(iris)
pairs(iris)
s = factor(Species)
pairs(iris, col = s)
fit = lm(Petal.Width ~ Sepal.Length + Sepal.Width + Petal.Length + s)
summary(fit)
fit = lm(Petal.Width ~ Sepal.Length * Sepal.Width * Petal.Length * s)
summary(fit)
fit1 = lm(Petal.Width ~ Sepal.Length + Sepal.Width + Petal.Length + s)
summary(fit1)
fit2 = lm(Petal.Width ~ Sepal.Length * Sepal.Width * Petal.Length * s)
summary(fit2)
partFTest = anova(fit1, fit2)
summary(partFTest)
anova(fit1, fit2)
library(knitr)
kable(data)
?round
v = 2.366454
round(v,0)
round(v,3)
#Set working directory to wherever Dilutions2.Rmd and DrugDoseReponses.csv are located
#setwd("/Users/tylershimko/Desktop/Dose_Response_Dilution_Calculator")
#Function to determine miligrams necessary to make stock solution
miligrams = function(molweight, totalvol, milimol){
x = milimol/1000
x = x*molweight*totalvol
x
}
#Dilution calculation
dilute = function(startConc, finConc, volume){
(finConc/startConc)*volume
}
#Function to make set of necessary dilutions
makeDilute = function(dilutions, stock, volume){
ul = c()
#Caluculate the dilution for each of the requested dilutions
for (i in seq(1,length(dilutions))){
dil = dilute(stock, dilutions[i], volume)
ul[i] = dil
}
#The total amount of lysate solution should be 10% of the total volume
lysate = .1*volume
#Repeat the amount of lysate, as it will be necessary tas the final column in
lysate2 = rep(lysate, each = length(dilutions))
#
solv = c()
for (i in seq(1,length(dilutions))){
solv[i] = volume - ul[i] - lysate
}
#Get a vector of the final concentrations
concentrations = c()
for (i in seq(1,length(dilutions))){
concentrations[i] = dilutions[i]
}
#Make a data frame of the type of solvent used (DMSO, water, etc.), the final concentrations, the amount of stock drug/compound solution to added in uL, and the total amount of lysate added for that dilution step
df = cbind(solvent,concentrations,solv,ul,lysate2)
}
#Get the compound names, molecular weights, solvents, and dilution curves from a csv file entitled "DrugDoseResponses.csv"
curves = read.csv("DrugDoseResponses.csv")
#Clean up the curves data so that only rows with complete, valid entries are used
curves2 = curves[curves[,5] != "" & curves[,3] != "NA" & curves[,4] != "",]
curves2 = curves2[is.na(curves2[,1]) == FALSE,]
volume = as.numeric(as.character(readline("What volume would you like to use? (in uL): ")))
setwd("~/Andersen-Lab-Code/Dilutions")
#Set working directory to wherever Dilutions2.Rmd and DrugDoseReponses.csv are located
#setwd("/Users/tylershimko/Desktop/Dose_Response_Dilution_Calculator")
#Function to determine miligrams necessary to make stock solution
miligrams = function(molweight, totalvol, milimol){
x = milimol/1000
x = x*molweight*totalvol
x
}
#Dilution calculation
dilute = function(startConc, finConc, volume){
(finConc/startConc)*volume
}
#Function to make set of necessary dilutions
makeDilute = function(dilutions, stock, volume){
ul = c()
#Caluculate the dilution for each of the requested dilutions
for (i in seq(1,length(dilutions))){
dil = dilute(stock, dilutions[i], volume)
ul[i] = dil
}
#The total amount of lysate solution should be 10% of the total volume
lysate = .1*volume
#Repeat the amount of lysate, as it will be necessary tas the final column in
lysate2 = rep(lysate, each = length(dilutions))
#
solv = c()
for (i in seq(1,length(dilutions))){
solv[i] = volume - ul[i] - lysate
}
#Get a vector of the final concentrations
concentrations = c()
for (i in seq(1,length(dilutions))){
concentrations[i] = dilutions[i]
}
#Make a data frame of the type of solvent used (DMSO, water, etc.), the final concentrations, the amount of stock drug/compound solution to added in uL, and the total amount of lysate added for that dilution step
df = cbind(solvent,concentrations,solv,ul,lysate2)
}
#Get the compound names, molecular weights, solvents, and dilution curves from a csv file entitled "DrugDoseResponses.csv"
curves = read.csv("DrugDoseResponses.csv")
#Clean up the curves data so that only rows with complete, valid entries are used
curves2 = curves[curves[,5] != "" & curves[,3] != "NA" & curves[,4] != "",]
curves2 = curves2[is.na(curves2[,1]) == FALSE,]
volume = as.numeric(as.character(readline("What volume would you like to use? (in uL): ")))
compound = as.character(curves2[i,1])
solvent = as.character(curves2[i,3])
####Next section is an artifact of an older version of this code that calculated the amount of powder necessary to make a stock solution
makeSol = "no"
if (makeSol == "yes"){
makeStock = as.numeric(as.character(readline("What concentration does the stock solution need to be? (in mM): ")))
stock = makeStock*1000
molMass = as.numeric(as.character(readline("What is the molecular weight of the compound?: ")))
finalVol = as.numeric(as.character(readline("What is the final volume you would like to make? (in mL): ")))
mgs = miligrams(molMass, finalVol, makeStock)
stockmake = paste("To make a", makeStock, "mM solution, dissolve", mgs, "mg in", finalVol, "mL of", solvent)
}
if (makeSol == "no"){
stockmake = "Already made"
stock = as.numeric(as.character(curves2[i,4]))
stock1 = stock*1000
}
####End artifact
#Read in the dilution curves and save as a numeric vector
dilutes = as.character(as.character(curves2[i,5]))
dilutes = gsub(" ", "", dilutes)
dilutes = as.numeric(unlist(strsplit(dilutes, ",")))
#Get the date
date = Sys.Date()
date = as.character(format(date, format = "%m%d%Y"))
#This section checks a series of ten-fold dilutions to see which stock concentration is most effecient at creating a dilution curve that is "pipettable" (not pipetting less than .5 ul), and not above 1% diluent so as to control for diluent effects
tenfolds = c(stock1/10000, stock1/1000, stock1/100, stock1/10, stock1)
count = c()
for (j in seq(1,length(tenfolds))) {
#Create a recipe data frame for each of the 10 fold dilutions listed above
recipe = as.data.frame(makeDilute(dilutes,tenfolds[j],volume))
#Count the total dilution amounts and check how many fall in our magic range of 0.5<x<12, 12 is 1% of the 1200 uL volume we are making up
count[j] = sum(as.numeric(as.character(recipe[,4])) >=.5 & as.numeric(as.character(recipe[,4])) <= 12)
}
#Check if all of the counts are zero, if this is true, you cannot make of the dilutions with the stock concentration you already have
if (all(count == 0L) == TRUE){
#Sets brake variable equal to TRUE, this is used in the markdown file to tell us that our stock is not concentrated enough for this curve
brake = TRUE
} else {
brake = FALSE
}
#Determine which dilution has the highest number of dilutions that can be made
index = which(count == max(count))
stock2 = tenfolds[index]
#If multiple stocks can make the same number of dilutions, take the lower concentration stock, this is arbitrary, as anyone could be used. However, using the lowest working stock controls pretty well for only needing to use a higher stock later on.
stock2 = stock2[1]
#If the stock you need is more dilute than the one you have, this will tell you how to dilute the one you have
if (stock2 != stock1){
stockmake = paste0("You must make a ", stock1/stock2, "-fold dilution of the ", stock, " mM stock that is already made.")
}
#Make the recipe
recipe = as.data.frame(makeDilute(dilutes,stock2, volume))
source('~/Andersen-Lab-Code/Dilutions/Dilutions2.R', echo=TRUE)
stockmake = readRDS("stockmake.rds")
recipe = readRDS("recipe.rds")
brake = readRDS("brake.rds")
roundVolume = function(x){
if(x <= 2){
return(as.character(round(x,3)))
} else if(x <= 20){
return(as.character(round(x,2)))
} else if(x <= 200){
return(as.character(round(x,1)))
} else {
return(as.character(round(x,0)))
}
}
View(recipe)
recipe[,c(4,6)] = sapply(recipe[,c(4,6)], roundVolume)
View(recipe)
View(recipe)
source('~/Andersen-Lab-Code/Dilutions/Dilutions2.R', echo=TRUE)
source('~/Andersen-Lab-Code/Dilutions/Dilutions2.R', echo=TRUE)
source('~/Andersen-Lab-Code/Dilutions/Dilutions2.R', echo=TRUE)
source('~/Andersen-Lab-Code/Dilutions/Dilutions2.R', echo=TRUE)
source('~/Andersen-Lab-Code/Dilutions/Dilutions2.R', echo=TRUE)
View(recipe)
View(highRecipe)
View(highRecipe)
View(recipe)
View(highRecipe)
View(recipe)
View(recipe)
source('~/Andersen-Lab-Code/Dilutions/Dilutions2.R', echo=TRUE)
source('~/Andersen-Lab-Code/Dilutions/Dilutions2.R', echo=TRUE)
source('~/Andersen-Lab-Code/Dilutions/Dilutions2.R', echo=TRUE)
source('~/Andersen-Lab-Code/Dilutions/Dilutions2.R', echo=TRUE)
source('~/Andersen-Lab-Code/Dilutions/Dilutions2.R', echo=TRUE)
